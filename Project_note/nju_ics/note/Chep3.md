# 程序的转换及机械级表示
W5-1-1(程序与指令的关系)
主要介绍IA-32指令系统：如何将高级语言程序转化为用机械指令表示的机械代码。
知道个大概就完了，想查表什么的，看王爽的《汇编语言》
程序由指令组成
* 程序在执行前
数据和指令事先存放在存储器中，每条指令和每个数据都有地址， 指令按序存放，指令由OP、ADDR字段组成，程序起始地址置PC
*  开始执行程序 
1. 第一步:根据PC取指令(从5号架上取菜谱) 
2. 第二步:指令译码(看菜谱) 
3. 第三步:取操作数(从架上或盘中取原材料) 
4. 第四步:指令执行(洗、切、炒等具体操作) 
5. 第五步:回写结果(装盘或直接送桌) 
6. 第六步:修改PC的值(算出下一菜谱所在架子号6=5+1)，继续执行下一条指令(继续做下一道菜)

* 程序启动前，指令和数据都存放在存储器中，形式上没有差别， 都是0/1序列
* 采用”存储程序“工作方式:  – 程序由指令组成，程序被启动后，计算机能自动取出一条一条指令执行，在执行过程中无需人的干预。
* • 指令执行过程中，指令和数据被从存储器取到CPU，存放在CPU 内的寄存器中，指令在IR中，数据在GPR中。

指令中需给出的信息:
1. 操作性质(操作码)
2. 源操作数1 或/和 源操作数2 (立即数、寄存器编号、存储地址) 
3. 目的操作数地址 (寄存器编号、存储地址) 
   存储地址的描述与操作数的数据结构有关!(操作数是数组的结构，或者是结构的分量，有相应的寻址方式)

任何高级语言程序最终通过执行若干条指令来完成!
***“指令”的概念***
计算机中的指令有微指令、机器指令和伪(宏)指令之分
* 机器指令处于硬件和软件的交界面
相当于一个菜谱指定的一个完整做菜过程         
--- 本章中提及的指令都指机器指令
* 微指令是微程序级命令，属于硬件范畴
---相当于洗、切、煮、炒等做菜“微过程“
* 伪指令是由若干机器指令组成的指令序列，属于软件范畴 相当于由多个菜谱合成一个”大菜“的过程
* 汇编指令是机器指令的汇编表示形式，即符号表示
* 机器指令和汇编指令一一对应，它们都与具体机器结构有关，都属于机器级指令
  
***机械级指令***
、、、
***高级语言程序转换为机械代码的过程***
GCC 使用、、、
test.o:可重定位目标文件 test:可执行目标文件: 这两个文件反汇编出的汇编指令相同，仅地址不同。可执行是一个确切的地址(虚拟地址)

***指令集体系结构(ISA)***
* ISA指 Instruction Set Architecture,即指令集体系结构
* ISA是一种规约(Specification)，它规定了如何使用硬件
1. 可执行的指令的集合，包括指令格式、操作种类以及每种操作对应的操作数的相应规定; 
2. 指令可以接受的操作数的类型; 
3. 操作数所能存放的寄存器组的结构，包括每个寄存器的名称、编号、 长度和用途; 
4. 操作数所能存放的存储空间的大小和编址方式;
5. 操作数在存储空间存放时按照大端还是小端方式存放;
6. 指令获取操作数的方式，即寻址方式;
7. 指令执行过程的控制方式，包括程序计数器、条件码定义等。
* ISA在计算机系统中是必不可少的一个抽象层，Why?
1. 没有它，软件无法使用计算机硬件! 
2. 没有它，一台计算机不能称为“通用计算机”
ISA和计算机组成(Organization，即MicroArchitecture：微体系结构)是何关系?
ISA是计算机组成的抽象；
计算机组成必须能够实现ISA规定的功能，如提供GPR、标志、运算电路等 同一种ISA可以有不同的计算机组成，如乘法指令可用ALU或乘法器实现

***对IA-32的体系结构的探究***
寄存器个数及各自功能?寄存器宽度?存储空间大小?编址单位? 指令格式?指令条数?指令操作功能?寻址方式?数据类型? 小端/大端?标志寄存器各位含义?PC位数?I/O端口编址方式?

W5-2-1（Inter处理器概述）支持的数据类型，通用寄存器组织，标志寄存器，寻址方式。
**IA-32/x64指令系统概述**
W5-2-2(IA-32的寄存器组织)
一个字为16位，长度后缀为w；32位为双字，长度后缀为l；
IA-32支持的数据类型及格式，IA-32的寄存器组织，IA-32的寄存器组织
重要认识
1. 计算机中所有运算都基于加法器实现!
2. 加法器不知道所运算的是带 符号数还是无符号数
3. 加法器不判定对错，总是取 低n位作为结果，并生成标志信息
计算机中的算盘就是加法器
W5-2-3(IA-32的寻址方式)
***IA-32的寻址方式***
* 寻址方式
  1. 如何根据指令给定信息得到操作数或操作数地址
* 操作数所在的位置
  1. 指令中:立即寻址
  2.  寄存器中:寄存器寻址
  3.   存储单元中(属于存储器操作数，按字节编址):其他寻址方式
* 存储器操作数的寻址方式与微处理器的工作模式有关 
  1. 两种工作模式:实地址模式和保护模式
* 实地址模式(基本用不到)
  1. 为与8086/8088兼容而设，加电或复位时 
  2. 寻址空间为1MB，20位地址:(CS)<<4+(IP)
* 保护模式(需要掌握) 
  1. 加电后进入，采用虚拟存储管理，多任务情况下隔离、保护
  2.  80286以上微处理器的工作模式 
  3.  寻址空间为$2^{32}$B，32位线性地址分段(段基址+段内偏移量)   
**保护模式下的寻址方式**
、、、、
W5-2-4 高级语言程序中寻址举例
**存储器操作数的寻址方式**、、、
```
int x;
float a[100]; 
short b[4][4];
char c;
double d[10];
各变量应采用什么寻址方式？
```
x、c:位移 / 基址
a[i]:104+i×4，比例变址+位移 
d[i]:544+i×8，比例变址+位移 
b[i][j]: 504+i×8+j×2，基址+比例变址+位移 将b[i][j]取到AX中的指令可以是:
“movw 504(%ebp,%esi,2), %ax”
其中， i×8在EBP中，j在ESI中，2为比例因子

W5-2-5 IA-32机器指令格式
**IA-32机器指令格式** P102
位移量和立即数都可以是:1B/2B/4B SIB中基址B和变址I都可是8个GRS中任一个;SS给出比例因子
操作码:opcode; W:与机器模式(16 / 32位)一起确定寄存器位数(AL / AX / EAX); D:操作方向(确定源和目标)
寻址方式(ModRM字节): mod、r/m、 reg/op三个字段与w字段和机 器模式(16/32)一起确定操作数所在的寄存器编号或有效地址计算方式

***总结***
* IA-32是典型的CISC(复杂指令集计算机)风格ISA
    1. 8个通用寄存器(8位、16位、32位) 
    2. 2个专用寄存器:EIP(PC)、标志寄存器EFLAGS  
    3. 6个段寄存器(间接给出段基址) 
    4. 存储器地址空间为4GB，按字节编址，小端方式 
    5. 寻址方式
       * 立即、寄存器、存储器(SR:[B]+[I]*s+A)(段基址+有效地址(偏移量))(8(%edx,%eax,4))
       * 相对寻址
    6. 变长指令字、变长操作码
* 汇编语言格式
  1. Intel格式汇编
  2. AT&T格式汇编(本课程使用)

W6-1-1(常用传送指令)
* 传送指令
  * 通用数据传送指令
  * 地址传送指令
  * 输入输出指令
  * 标志传送指令
**程序由指令序列组成**
W6-1-2(传送指令过程)(P120)
**视频讲解了传送的过程，看看**

W6-2-1(常用定点运算指令)(book:3.3.2)
* 定点算术运算指令
  * 加 / 减运算(影响标志、不区分无/带符号)
  * 增1 / 减1运算(影响除CF以外的标志、不区分无/带符号)
  * 取负运算(影响标志、若对0取负，则结果为0且CF清0，否则CF置1)
  * 比较运算(做减法得到标志、不区分无/带符号)
  * 乘 / 除运算(不影响标志、区分无/带符号)

**整数乘除指令**
* 乘法指令:可给出一个、两个或三个操作数
* 除法指令:只明显指出除数，用EDX-EAX中内容除以指定的除数
  

W6-2-2 (加法运算的底层实现举例)
**讲解挺好，和书有出入，不写了，完了自己看看**

### **ALU**长什么样？(看书)
* 试想一下ALU中有哪些部件?
  1. 补码加/减器(可以干什么?)
    * 带符号整数加、减
    * 无符号整数加、减
  2. ~~乘法器~~?(为什么可以没有)
     * 可用加/减+移位实现，也可有独立乘法器 
     *  带符号乘和无符号乘是独立的部件
  3. ~~除法器~~?(为什么可以没有)
     * 可用加/减+移位实现，也可有独立除法器
     * 带符号除和无符号除是独立的部件
  4. 各种逻辑运算部件(可以干什么)
     * 非、与、或、非、前置0个数、前置1个数.......

W6-2-3 (加法指令和乘法指令举例) P107
* 定点加法指令举例 
* 定点乘法指令举例
回头看完书，再返回看吧

W6-3-1(逻辑运算和移位指令)-book_3.3.3
加了一堆举例，以后可以看看
* 逻辑运算
* 移位运算

W6-3-2 (按位运算指令举例)
逆向工程:从汇编指令推断出高级语言程序代码
在高级语言中，代码的移位不被区分，在汇编指令中，带符号：算术移位；无符号：逻辑移位；

W6-4-1(条件转移指令举例)
* 控制转移指令 ——指令执行可按顺序 或 跳转到转移目标指令处执行
  1. 无条件转移指令
    JMP DST:无条件转移到目标指令DST处执行
  2. 条件转移
    Jcc DST:cc为条件码，根据标志(条件码)判断是否满足条件，若满足，则转移到目标指令DST处执行，否则按顺序执行
  3. 条件设置
    SETcc DST:按条件码cc判断的结果保存到DST(是一个8位寄存器 )
  4. 调用和返回指令 (用于过程调用)
    CALL DST:返回地址RA入栈，转DST处执行 RET:从栈中取出返回地址RA，转到RA处执行
  5. 中断指令 (详见第7、8章)

* 程序的机器级表示与执行；例子很好，学汇编或着cs61c的时候再说。
 （有个大概就行）

W6-4-2(条件设置指令举例)
|**C表达式类型转换顺序**(从上到下)|
|:---:|
|(unsigned)char,(unsigned)short|
|int|
|unsigned|
|long long|
|unsigned long long|

W6-5-1(x87 FPU常用指令)  
* **IA-32的浮点处理架构有两种：**
1. x87FPU指令集(gcc默认)
2. SSE指令集(x86-64架构所用)
* **IA-32中处理的浮点数有三种类型
  1. float类型:32位 IEEE 754 单精度格式
  2. double类型:64位 IEEE 754 双精度格式
  3. long double类型:80位双精度扩展格式

1位符号位s、15位阶码e(偏置常数为16 383)、1位显式 首位有效位(explicit leading significant bit)j 和 63位 尾数f。它与IEEE 754单精度和双精度浮点格式的一个重要的 区别是:它没有隐藏位，有效位数共64位。
**x87 FPU指令**
* 早期的浮点处理器是作为CPU的外置协处理器出现的 
* x87 FPU 特指与x86处理器配套的浮点协处理器架构
  1. 浮点寄存器采用栈结构
     1. 深度为8，宽度为80位，即8个80位寄存器• 
     2. 名称为 ST(0) ~ ST(7)，栈顶为ST(0)，编号分别为 0~7
  2. 所有浮点运算都按80位扩展精度进行
  3. 浮点数在浮点寄存器和内存之间传送
       * float、double、long double型变量在内存分别用IEEE 754单精 度、双精度和扩展精度表示，分别占32位(4B)、64位(8B)和 96位(12B，其中高16位无意义)
       * float、double、long double类型变量在浮点寄存器中都用80位 扩展精度表示
       * 从浮点寄存器到内存:80位扩展精度格式转换为32位或64位
       * 从内存到浮点寄存器: 32位或64位格式转换为80位扩展精度格式

* 数据传送类
  1. 装入(转换为80位扩展精度)
    FLD:将数据从存储单元装入浮点寄存器栈顶 ST(0)
    FILD:将数据从int型转换为浮点格式后，装入浮点寄存器栈顶
  2. 存储(转换为IEEE 754单精度或双精度)
    FSTx:x为s/l时，将栈顶ST(0)转换为单/双精度格式，然后存入存储单元
    FSTPx:弹出栈顶元素，并完成与FSTx相同的功能 
    FISTx:将栈顶数据从int型转换为浮点格式后，存入存储单元 
    FISTP:弹出栈顶元素，并完成与FISTx相同的功能
**带P结尾指令表示操作数会出栈，也即ST(1)将变成ST(0)**
* 数据传送类
  3. 交换
      FXCH：交换栈顶和次栈顶两元素
  4. 常数装载到栈顶
      FLD1 :装入常数1.0
      FLDZ :装入常数0.0
      FLDPI :装入常数pi (=3.1415926...) FLDL2E :装入常数log(2)e
      FLDL2T :装入常数log(2)10
      FLDLG2 :装入常数log(10)2
      FLDLN2 :装入常数Log(e)2
* 算术运算类
  1. 加法
      FADD/FADDP: 相加/相加后弹出栈
      FIADD:按int型转换后相加
  2. 减法
      FSUB/FSUBP : 相减/相减后弹出栈 FSUBR/FSUBRP:调换次序相减/相减后弹出栈 FISUB:按int型转换后相减 FISUBR:按int型转换并调换次序相减
      ```
      若指令未带操作数，则默认操作数为ST(0)、ST(1) 带R后缀指令是指操作数顺序变反，例如: fsub执行的是x-y，fsubr执行的就是y-x
      ```
  3. 乘法
      FMUL/FMULP: 相乘/相乘后弹出栈
      FIMUL:按int型转换后相乘
  4. 除法
      FDIV/FDIVP : 相除/相除后弹出栈 
      FIDIV:按int型转换后相除 
      FDIVR/FDIVRP:调换次序相除/相减后弹出栈 
      FIDIVR:按int型转换并调换次序相除


W6-5-2(x87浮点处理指令举例)
IA-32浮点操作举例 textbook_3.3.5


W6-6 (MMX及SSE指令集)
**MMX/SSE指令集的由来**
* 由MMX发展而来的SSE架构
    1. MMX指令使用8个64位寄存器MM0~MM7，借用8个80位寄存 器ST(0)~ST(7)中64位尾数所占的位，可同时处理8个字节，或4 个字，或2个双字，或一个64位的数据, 是一种SIMD技术(一个指令，可操作多个数据类型，是数据集的技术)
    2. MMX指令并没带来3D游戏性能的显著提升，故推出SSE指令， 并陆续推出SSE2、SSE3、SSSE3和SSE4等采用SIMD技术的指令集，这些统称为SSE指令集
    3. SSE指令集将80位浮点寄存器扩充到128位多媒体扩展通用寄存 器XMM0~XMM7，可同时处理16个字节，或8个字，或4个双字(**32位整数或单精度浮点数**)，或两个四字的数据
    4. 从SSE2开始，还支持128位整数运算，或同时并行处理两个64位 双精度浮点数

***IA-32中通用寄存器中的编号***反映了体系结构发展的轨迹，字长不断扩充，指令保持兼容 ST(0)~ ST(7)是80位，MM0 ~MM7使用其低64位

**SSE指令(SIMD操作)**
* paddb指令(操作数在两个xmm寄存器中)
  * 一条指令同时完成16个单字节数据相加
  * 类似指令paddw同时完成8个单字数据相加 
  * 类似指令psubl同时完成4个双字数据相减
* movdqa指令
  * 将双四字(128位)从源操作数处移到目标操作数处
  * 用于在 XMM 寄存器与 128 位存储单元之间移入/移出双 四字，或在两个 XMM 寄存器之间移动
  * 源操作数或目标操作数是存储器操作数时，操作数必须是 16 字节边界对齐，否则将发生一般保护性异常 (#GP)
* movdqu指令
  * 在未对齐的存储单元中移入/移出双四字


更多有关SSE指令集的内容请参看Intel的相关资料


### C语言程序的机械级表示
包括：1.如何传递参数； 2.如何将控制转移到被调用过程； 3.寄存器使用约定； 4.递归函数的实现；
W7-1-1(过程调用概述)
**过程调用的机械级表示**
例子(textbook_122)-问题：
1. 以下过程(函数)调用对应的机器级代码是什么?
2. 如何将t1(125)、t2(80)分别传递给add中的形式参数x、y 
3. add函数执行的结果如何返回给caller?

return 参数通过栈(stack)来传递；栈在哪？？？
可执行文件的存储器映像···

过程调用的执行步骤(P为调用者，Q为被调用者)
1. P将入口参数(实参)放到Q能访问到的地方; 
2. P保存返回地址，然后将控制转移到Q;CALL指令 
3. Q保存P的现场，并为自己的非静态局部变量分配空间; 
4. 执行Q的过程体(函数体); 处理阶段 
5. Q恢复P的现场，释放局部变量空间;
6. Q取出返回地址，将控制转移到P
   1，2为P过程；3，4，5，6为Q过程；
何为现场? ___通用寄存器的内容  
为何要保存现场?___因为所有过程共享一套通用寄存器；

* **IA-32的寄存器使用约定**
  1. 调用者保存寄存器:EAX、EDX、ECX
      当过程P调用过程Q时，Q可以直接使用这三个寄存器，不用 将它们的值保存到栈中。如果P在从Q返回后还要用这三个寄 存器的话，P应在转到Q之前先保存，并在从Q返回后先恢复 它们的值再使用。
  2. 被调用者保存寄存器:EBX、ESI、EDI
      Q必须先将它们的值保存到栈中再使用它们，并在返回P之前恢复它们的值。
  3. EBP和ESP分别是帧指针寄存器和栈指针寄存器，分别用来指 向当前栈帧的底部和顶部。
问题:为减少准备和结束阶段的开销，每个过程应先使用哪些寄存器?————————EAX、ECX、EDX!

W7-1-2(过程(函数)的机械级代码结构)
***过程(函数)的结构***
  * 一个C过程的大致结构如下：
    1. 准备阶段
       1. 形成帧底:push指令 和 mov指令
       2. 生成栈帧(如果需要的话):sub指令 或 and指令
       3. 保存现场(如果有被调用者保存寄存器) :mov指令
    2. 过程(函数)体
       1. 分配局部变量空间，并赋值
       2. 具体处理逻辑，如果遇到函数调用时
          1. 准备参数:将实参送栈帧入口参数处 
          2. CALL指令:保存返回地址并转被调用函数 :先将地址压栈..
       3. 在EAX中准备返回参数
    3. 结束阶段
       1. 退栈:leave指令 或 pop指令()__:把栈底的信息全部释放掉，把地址弹到通用寄存器中，使ESP指向栈底
       2. 取返回地址返回:ret指令：根据ESP，取出返回地址

W7-1-3(过程调用的参数传递)
***入口参数的位置***,打字不太行，回头看看

***过程调用参数传递举例***textbook_P124

W7-1-4(过程调用举例)
,,,看视频，书_textbook_P128
W7-1-5(递归过程调用举例)
,,,讲解，可以

W7-1-6(过程调用举例)
```
double fun(int i)
{
volatile double d[1] = {3.14};
volatile long int a[2];
a[i] = 1073741824;
return d[0];
}
```
f(0)$\rightarrow$ 3.14
f(1)$\rightarrow$ 3.14
f(2)$\rightarrow$ 3.13999986
f(3)$\rightarrow$ 2.000000610
f(4)$\rightarrow$ 3.14,然后储存保护错
```
为何每次返回不一样?
为什么会引起保护错?
栈帧中的状态如何?
不同系统上执行结果可能不同
例如，编译器对局部变量分配方式可能不同
```
|EBP的旧值$\leftarrow$EBP|
|:---|
|d7...d4|
|d3...d0|
|a[1]|
|a[0]$\leftarrow$ESP|

$$
发生的情况=\begin{cases}
当i=0或1，OK\\
当i=2, d3~d0=0x40000000 低位部分(尾数)被改变\\ 当i=3, d7~d3=0x40000000 高位部分被改变\\
当i=4, EBP被改变
\end{cases}
$$

W7-2(选择结构的机械级表示)
if-else语句的机械级代码结构；switch-case语句的机械级代码结构；循环语句的机械级代码结构；循环结构和递归过程调用的比较；
textbook_P133
* if-else语句举例
* switch-case语句举例
    跳转表，switch中的细节；

W7-3 (循环结构的机械级表示)
* **循环结构的机械级表示**

* do~while循环的机器级表示
* while循环的机器级表示
* for循环的机器级表示

**循环结构与递归的比较**
**通常复杂局部变量被分配在栈中，而这里都是简单变量**

* **逆向工程**


W8-1-1(数组的分配与访问)

数组元素在内存的存放和访问；分配在静态区的数组的初始化和访问；auto型数组的初始化和访问；数组与指针之间的关系；指针数组和多维数组；

***数组的分配和访问***textbook_P141
* 数组元素在内存的存放和访问
  * 类型数组A，可以写成“static short A[4];”
  * 第 i(0≤i≤3)个元素的地址计算公式为&A[0]+2*i。
  * 假定数组A的首地址存放在EDX中，i 存放在ECX中，现要将A[i]取到AX中，则所用的汇编指令是什么?``movw (%edx, %ecx, 2), %ax``比例因子是2；其中，ECX为变址(索引)寄存器，在循环体中增量

W8-1-2(数组与指针的关系)
* 数组与指针
  * 在指针变量目标数据类型与数组 类型相同的前提下，指针变量可以指向数组或数组中任意元素
  * 以下两个程序段功能完全相同， 都是使ptr指向数组a的第0个元 素a[0]。a的值就是其首地址， 即a=&a[0]，因而a=ptr，从而 有&a[i]=ptr+i=a+i以及 a[i]=ptr[i]=*(ptr+i)=*(a+i)。
```
(1)int a[10];
      int *ptr=&a[0];
(2) int a[10], *ptr; 
    ptr=&a[0];
```

W8-1-3(指针数组和多维数组)

* **指针数组和多维数组**
  * 由若干指向同类目标的指针变量组成的数组称为指针数组。 
  * 其定义的一般形式如下:存储类型 数据类型 *指针数组名[元素个数];(根据存储类型区分数组是分配在存储区还是栈中)
  * 例如，“int *a[10];”定义了一个指针数组a，它有10个元 素，每个元素都是一个指向int型数据的指针。
      *  一个指针数组可以实现一个二维数组。
textbook_P143

W8-2-1(结构类型的分配和访问)

* **结构体数据的分配和访问**
  * 结构体成员在内存的存放和访问
    * 分配在栈中的auto结构型变量的首地址由EBP或ESP来定位 
    * 分配在静态区的结构型变量首地址是一个确定的静态区地址
    * 结构型变量 x 各成员首址可用“基址加偏移量”的寻址方式

* **结构体数据作为入口参数**
  * 当结构体变量需要作为一个函数的形参时，形参和调用函数中的实参应具有相同结构
  * 有按值传递和按地址传递两种方式
    * 若采用按值传递，则结构成员都要复制到栈中参数区，这**既增加时间开销又增加空间开销，且更新后的数据无法在调用过程使用**
    * 通常应按地址传递，即:在执行CALL指令前，仅需传递指向结构体的指针而不需复制每个成员到栈中

W8-2-2(联合类型的分配和访问)
联合体各成员共享存储空间，按最大长度成员所需空间大小为目标
* 通常用于特殊场合，如，当事先知道某种数据结构中的不同字段的使用时间是互斥的，就可将这些字段声明为联合，以减少空间。
*  但有时会得不偿失，可能只会减少少量空间却大大增加处理复杂性。
*  还可实现对相同位序列进行不同数据类型的解释(textbook_P147)
*  利用嵌套可定义链表结构

W8-3-1(数据的对齐方式)textbook_P149
简单变量的对齐；结构和联合类型的对齐；C语言程序中对齐方式的设定；

Alignment:要求数据的地址是相应的边界地址
* 指令系统支持对字节、半字、字及双字的运算 
* 各种不同长度的数据存放时，有两种处理方式:
  * 按边界对齐(若一个字为32位) 
    * 字地址:4的倍数(低两位为0) 
    * 半字地址:2的倍数(低位为0)  
    * 字节地址:任意
  * 不按边界对齐 
    * 坏处:可能会增加访存次数!(学了存储器组织后会更明白!)

对齐(Alignment);按边界对齐的举例
* 最简单的对齐策略是:按其数据长度进行对齐。例如，
  * Windows采用策略:int型地址是4的倍数，short型地址是2 的倍数，double和long long型的是8的倍数，float型的是4 的倍数，char不对齐
  * Linux采用更宽松策略:short型是2的倍数，其他类型如int、 float、double和指针等都是4的倍数

W8-3-2(数据对齐方式举例)
* **对齐方式的设定**
``#pragma pack(n)``
  * 为编译器指定结构体或类内部的成员变量的对齐方式。
  * 当自然边界(如int型按4字节、short型按2字节、float按4字节)比n大时，按n字节对齐。
  * 缺省或#pragma pack() ，按自然边界对齐。
``_attribute_((aligned(m)))``
  * 为编译器指定一个结构体或类或联合体或一个单独的变量(对象)的对齐方式。
  * 按m字节对齐(m必须是2的幂次方)，且其占用空间大小也是m的 整数倍，以保证在申请连续存储空间时各元素也按m字节对齐。

``_attribute_((packed))``
  * 不按边界对齐，称为紧凑方式。
举例看

W8-4(越界访问和缓存区溢出攻击)*讲的很多看看
* **越界访问和缓存区溢出**
  * C语言程序中对数组的访问可能会有意或无意地超越数组存储区范围 而无法发现。
  * 数组存储区可看成是一个缓冲区，超越数组存储区范围的写入操作 称为缓冲区溢出。
    * 例如，对于一个有10个元素的char型数组，其定义的缓冲区有10个字 节。若写一个字符串到这个缓冲区，那么只要写入的字符串多于9个字 符(结束符‘\0’占一个字节)，就会发生“写溢出”。
  * 缓冲区溢出是一种非常普遍、非常危险的漏洞，在各种操作系统、 应用软件中广泛存在
  * 缓冲区溢出攻击是利用缓冲区溢出漏洞所进行的攻击。利用缓冲区 溢出攻击，可导致程序运行失败、系统关机、重新启动等后果。

* execve()函数的用法如下:
int execve(char *filename, char *argv[], *envp[]);
filename是加载并运行的可执行文件名(如./hello)，可带参数列表 argv和环境变量列表envp。若错误(如找不到指定文件filename) ，则返回-1，并将控制权交给调用程序; 若函数执行成功，则不返回 ，最终将控制权传递到可执行目标中的主函数main。

W9-1-1(x86-64指令系统概述)
x86-64架构指令系统____简要介绍x86-64指令系统的特点，也就是与IA-32指令系统所不同的地方，特别是过程调用时参数传递方式的不同。

* **兼容IA-32的64位系统**

**IA-32**(PPT有图)
IA-32架构由16位架构发展而来，因此，虽然字长为32位或更大 ，但一个字为16位，长度后缀为 w;32位为双字，长度后缀为 l
long double实际长度为80位，但分配96位=12B(按4B对齐)
**x86-64**(PPT有图)
  * 新增8个64位通用寄存器(整数寄存器)
    * R8、R9、R10、R11、R12、R13、R14和R15。
    * 可作为8位(R8B~R15B)、16位(R8W~R15W)或 32位寄存器(R8D~R15D)使用
  * 所有GPRs都从32位扩充到64位
    *  8个32位通用寄存器EAX、EBX、ECX、EDX、EBP、 ESP、ESI和 EDI对应扩展寄存器分别为RAX、RBX、 RCX、RDX、RBP、RSP、RSI和RDI
    *  EBP、ESP、ESI和 EDI的低8位寄存器分别是BPL、SPL 、SIL和DIL
    *  可兼容使用原AH、BH、CH和DH寄存器
      (使原来IA-32中的每个通用寄存器都可以是8位、16位、 32位和64位，如:SIL、SI、ESI、RSI)
**x86-64中寄存器的使用**
* 指令可直接访问16个64位寄存器:RAX、RBX、RCX、RDX、RBP、RSP、RSI、RDI，以及R8~R15
* 指令可直接访问16个32位寄存器:EAX、EBX、ECX、EDX、EBP、ESP、ESI、EDI，以及R8D~R15D
* 指令可直接访问16个16位寄存器:AX、BX、CX、DX、BP、SP、SI、DI，以及R8W~R15W
* 指令可直接访问16个8位寄存器:AL、BL、CL、DL、BPL、SPL、SIL、DIL，以及R8B~R15B
* 为向后兼容，指令也可直接访问AH、BH、CH、DH
* 通过寄存器传送参数，因而很多过程不用访问栈，因此，与IA-32 不同，x86-64不需要指针寄存器，即RBP可用作普通寄存器使用
* 程序计数器为64位寄存器RIP

回顾：IA-32的寄存器组织(看课)；x86-64通用寄存器
通用寄存器 个数从8个增 加到16个， 宽度从32位 增加到64位
增加了 %sil、 %dil、%bpl、 %spl 四个8位 寄存器
%riw为16位 %rib为8位 (i=8~15)(带w：为16位寄存器；带b：为8位寄存器；)

W9-1-2(x86-64指令系统概述2)
**x86-64的地址和寻址空间**
存储器操作数
* 字长从32位变为64位，64位(8B)数据被称为一个四字(qw: quadword)
* 逻辑地址最长可达为64位，即理论上可访问的存储空间达264字节或16EB(ExaByte) – 编译器为指针变量分配64位(8B)
* 基址寄存器和变址寄存器都应使用64位寄存器
* 但实际上，AMD和Intel的x86-64仅支持48位虚拟地址，因此，程序的虚拟地址空间大小为248=256TB

**x86-64的浮点寄存器**
* long double型数据虽然还采用80位(10B)扩展精度 格式，但所分配存储空间从12B扩展为16B，即改为 16B对齐方式，但不管是分配12B还是16B，都只用到低10B
* 128位的XMM寄存器从原来的8个增加到16个
* 浮点操作指令集采用基于SSE的面向XMM寄存器的指令集，而不采用基于浮点寄存器栈的 x87 FPU 指令集 
* 浮点操作数存放在XMM寄存器中

x86-64继承了IA-32中的8、16、32位通用寄存器和128位XMM寄存器 而取消了IA-32中的80位浮点寄存器栈ST(0)-ST(7)

**x86-64中数据的对齐**
* 各类型数据遵循一定的对齐规则，而且更严格
* 存储器访问接口被设计成按8字节或16字节为单位进行 存取，其对齐规则是，任何K字节宽的基本数据类型和 指针类型数据的起始地址一定是K的倍数。
  * short型数据必须按2字节边界对齐
  * int、float等类型数据必须按4字节边界对齐
  * long、double、指针型变量必须按8字节边界对齐 • long double型数据必须按16字节边界对齐

W9-2-1(传送指令)
传送指令；算术逻辑运算指令；比较和测试指令；逆向工程举例；
* **传送指令**
  * 数据传送指令(助记符“q”表示操作数长度为四字(即64位))
    * movabsq I, R:将64位立即数送64位通用寄存器
    * movsbq、movswq、movslq:将源操作数进行符号扩展并传送 到一个64位寄存器或存储单元中
    * movzbq、movzwq:将源操作数进行零扩展后传送到一个64位寄 存器或存储单元中
    * movl:的功能相当于movzlq指令
    * pushq S:R[rsp]←R[rsp]-8; M[R[rsp]] ←S
      popq D: D← M[R[rsp]]; R[rsp]←R[rsp]-8
(textbook_P160举例)

W9-2-2(算术逻辑运算指令)
* 常规的算术逻辑运算指令
  * 只要将原来IA-32中的指令扩展到64位即可。例如:
    * addq(四字相加)
    * subq(四字相减)
    * incq(四字加1)
    * decq(四字减1)
    * imulq(带符号整数四字相乘)
    * orq(64位相或)
    * salq(64位算术左移)
    * leaq(有效地址加载到64位寄存器)
* 特殊的算术逻辑运算指令
  * 对于x86-64，还有一些特殊的算术逻辑运算指令。例如:
    * imulq S:R[rdx]:R[rax]← S * R[rax] (64位*64位带符号整数) 
    * mulq S:R[rdx]:R[rax]← S * R[rax] (64位*64位无符号整数) 
    * cltq:R[rax] ← SignExtend(R[eax]) (将EAX内容符号扩展为四字) 
    * clto: R[rdx]:R[rax]← SignExtend(R[rax]) (符号扩展为八字) 
    * idivq S:R[rdx] ← R[rdx]:R[rax] mod S (带符号整数相除、余数)        
              R[rax] ← R[rdx]:R[rax]÷S (带符号整数相除、商) 
    * divq S:R[rdx] ← R[rdx]:R[rax] mod S (无符号整数相除、余数)          
              R[rax] ← R[rdx]:R[rax]÷S (无符号整数相除、商)
上述功能描述中，R[rdx]:R[rax]是一个128位的八字(oct word)
举例
* 比较和测试指令
  * 与IA-32中比较和测试指令类似。例如:
    * cmpq S2, S1:S1-S2 (64位数相减进行比较) 
    * testq S2, S1:S1∧S2 (64位数相与进行比较)
条件转移指令、条件传送指令、条件设置指令都根据上述比较指令和测试指令生成的标志进行处理

W9-2-3(x86-64逆向工程举例)
看PPT

W9-3-1(x86-64过程调用的参数传递方式)               
textbook上不详细
x86-64过程调用的参数传递；x86-64寄存器使用约定；x86-64过程调用举例；与IA-32过程调用的比较；
看slide不写了
在x86-64/Linux平台上用以 下命令执行汇编操作，得到 x86-64汇编指令代码
``$ gcc –O1 –S –m64 sample.c``
在x86-64/Linux平台上用以 下命令执行汇编操作，得到与 IA-32兼容的汇编指令代码(需要调用寄存器，命令更多)
``$ gcc –O1 –S –m32 sample.c``
    在x86-64/Linux x86-64格式代码，故可省略-m64
**x86-64过程调用的参数传递**
* 通过通用寄存器传送参数，很多过程不用访问栈，故执行时间比IA-32代码更短
* 最多可有6个整型或指针型参数通过寄存器传递
* 超过6个入口参数时，后面的通过栈来传递
* 在栈中传递的参数若是基本类型，则都被分配8个字节
* call(或callq)将64位返址保存在栈中之前，执行R[rsp]$\leftarrow$R[rsp]-8
* ret从栈中取出64位返回地址后，执行R[rsp]$\leftarrow$R[rsp]+8

**x86-64过程调用的寄存器使用约定**
在过程(函数) 中尽量使用寄 存器RAX、 R10和R11。若使用RBX、 RBP、R12、 R13、R14和 R15，则需要将它们先保存在栈中再使用 ，最后返回前再恢复其值
IA-32:中先用调用者寄存器(EAX,ECX,EDX),不够被调用者寄存器(EBX,ESI,EDI)

W9-3-2(x86-32过程调用举例)
textbook_P163

W9-3-3(IA-32和x86-64的比较举例)
textbook_P165
在IA-32中a为float又怎么样？先执行flds，再执行fstpl
即:flds将32位单精度转换为80位格式入浮点寄存器栈，fstpl再将 80位转换为64位送存储器栈中，故实际上与a是double效果一样!

**回顾：x86-64的浮点寄存器**
* long double型数据虽然还采用80位(10B)扩展精度 格式，但所分配存储空间从12B扩展为16B，即改为 16B对齐方式，但不管是分配12B还是16B，都只用到 低10B
* 128位的XMM寄存器从原来的8个增加到16个
* 浮点操作指令集采用基于SSE的面向XMM寄存器的指令集，而不采用基于浮点寄存器栈的 x87 FPU 指令集 
* 浮点操作数存放在XMM寄存器中